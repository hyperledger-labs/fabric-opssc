/*
 * Copyright 2020-2021 Hitachi America, Ltd. All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

import fs from 'fs-extra';
import { execCommand, findSingleFileOnThePath } from './utils';
import path from 'path';
import moment from 'moment';
import yaml from 'js-yaml';

export type ConfigTxProfile = {
  configUpdate: string;
  signatures: { [key: string]: string };
}

export type ChannelCommandsOptions = {
  workDir?: string;
  fabricConfigPath?: string;
  fabricLogLevel?: 'FATAL' | 'PANIC' | 'ERROR' | 'WARNING' | 'INFO' | 'DEBUG'
}

type PeerConfig = {
  address: string;
  tlsCACertFilePath: string;
}

const DEFAULT_RETRY_MAX = 10;
const DEFAULT_WAIT_MS = 800;

/**
 * <p> ChannelCommands is a class to execute commands to operate channels.
 * This class internally calls "peer" binary and "fabric-configtx-cli".
 * </p>
 *
 */
export class ChannelCommands {

  private readonly connectionProfile: any;
  private readonly mspID: string;
  private readonly mspConfigPath: string;
  private readonly options: ChannelCommandsOptions | undefined;
  private _outputDir: string | undefined;

  /**
   * ChannelCommands constructor
   *
   * @param {string} mspID the MSP ID to interact with peer channel sub commands
   * @param {string} mspConfigPath the MSP config path which has MSP to interact with peer channel sub commands
   * @param {any} connectionProfile the connection profile that provides the necessary connection information for the client organization
   * @param {ChannelCommandsOptions} [options] the channel commands options
   */
  constructor(mspID: string, mspConfigPath: string, connectionProfile: any, options?: ChannelCommandsOptions) {
    this.connectionProfile = connectionProfile;
    this.mspID = mspID;
    this.mspConfigPath = mspConfigPath;
    this.options = options;
  }

  /**
   * Send the supplied configtx update file to the channel (execute "peer channel update").
   *
   * @param {string} channelID the target channel ID
   * @param {string} configTxFilePath the path to configuration transaction file generated by a tool fabric-configtx-cli such as for submitting to orderer
   */
  update(channelID: string, configTxFilePath: string): void {

    const targetPeer = this.peerConfigs()[0];

    const command = ['peer', 'channel', 'update',
      '-c', channelID, '-f', configTxFilePath,
      ...this.peerCmdOrdererArgs()].join(' ');

    execCommand(command, undefined, undefined, {
      FABRIC_LOGGING_SPEC: this.logLevel(),
      FABRIC_CFG_PATH: this.configPath(),
      CORE_PEER_LOCALMSPID: this.mspID,
      CORE_PEER_MSPCONFIGPATH: this.mspConfigPath,
      CORE_PEER_TLS_ENABLED: 'true',
      CORE_PEER_ADDRESS: targetPeer.address,
      CORE_PEER_TLS_ROOTCERT_FILE: targetPeer.tlsCACertFilePath
    });
  }

  /**
   * Create a channel and return the genesis block (execute "peer channel create").
   *
   * @param channelID the target channel ID
   * @param configTxFilePath the path to configuration transaction file generated by a tool fabric-configtx-cli such as for submitting to orderer
   * @returns {Buffer} the genesis block
   */
  create(channelID: string, configTxFilePath: string): Buffer {

    const targetPeer = this.peerConfigs()[0];
    const blockFileName = `${channelID}_output_block.pb`;

    const command = ['peer', 'channel', 'create',
      '-c', channelID, '-f', configTxFilePath, '--outputBlock',
      path.join(this.outputDir(), blockFileName),
      ...this.peerCmdOrdererArgs()].join(' ');

    execCommand(command, undefined, undefined, {
      FABRIC_LOGGING_SPEC: this.logLevel(),
      FABRIC_CFG_PATH: this.configPath(),
      CORE_PEER_LOCALMSPID: this.mspID,
      CORE_PEER_MSPCONFIGPATH: this.mspConfigPath,
      CORE_PEER_TLS_ENABLED: 'true',
      CORE_PEER_ADDRESS: targetPeer.address,
      CORE_PEER_TLS_ROOTCERT_FILE: targetPeer.tlsCACertFilePath
    });

    return fs.readFileSync(path.join(this.outputDir(), blockFileName));
  }

  /**
   * <p> Join all the peers owned by the client organization described in the connection profile to the channel (execute "peer channel join").
   * This also confirms that each peer has joined the channel and waits for it (by executing "peer channel list").
   * </p>
   *
   * @async
   * @param {string} channelID the target channel ID
   * @returns {Buffer} the genesis block
   */
  async joinAllPeers(channelID: string): Promise<void> {

    // fetch the channel genesis block
    const blockPath = await this.fetch(channelID, 'oldest', 'filePath') as string;

    // join all peers for the organization to the channel
    // TODO: Should be paralleled
    const peerConfigs = this.peerConfigs();
    for (const targetPeer of peerConfigs) {
      try {
        // Join the target peer to the channel
        let command = ['peer', 'channel', 'join', '-b', blockPath].join(' ');

        execCommand(command, undefined, undefined, {
          FABRIC_LOGGING_SPEC: this.logLevel(),
          FABRIC_CFG_PATH: this.configPath(),
          CORE_PEER_LOCALMSPID: this.mspID,
          CORE_PEER_MSPCONFIGPATH: this.mspConfigPath,
          CORE_PEER_TLS_ENABLED: 'true',
          CORE_PEER_ADDRESS: targetPeer.address,
          CORE_PEER_TLS_ROOTCERT_FILE: targetPeer.tlsCACertFilePath
        });

        // Workaround: Wait for the target peer has joined in the channel
        command = ['peer', 'channel', 'list'].join(' ');
        for (let retry =  DEFAULT_RETRY_MAX; retry > 0; retry--) {
          const channelList = execCommand(command, undefined, undefined, {
            FABRIC_LOGGING_SPEC: this.logLevel(),
            FABRIC_CFG_PATH: this.configPath(),
            CORE_PEER_LOCALMSPID: this.mspID,
            CORE_PEER_MSPCONFIGPATH: this.mspConfigPath,
            CORE_PEER_TLS_ENABLED: 'true',
            CORE_PEER_ADDRESS: targetPeer.address,
            CORE_PEER_TLS_ROOTCERT_FILE: targetPeer.tlsCACertFilePath
          }).split('\n');
          if (channelList.includes(channelID)) {
            break;
          }
          await new Promise((resolve) => setTimeout(resolve, Math.random() * DEFAULT_WAIT_MS));
        }
        throw new Error(`Fail to join peer '${targetPeer.address}' to channel '${channelID}': wait timeout`);
      } catch (error) {
        if (error.message != null) {
          if ((error.message as string).includes('already exists')) {
            continue;
          }
        }
        throw error;
      }
    }
  }

  /**
   * Fetch a specific block (execute "peer channel fetch").
   *
   * @param {string} channelID the target channel ID
   * @param {"newest"|"oldest"|"config"|number} seek the block number to be fetched
   * @param {"filePath"|"buffer"} outputOption the output option
   * @returns {string|Buffer} the output file path in which the block is written if the option is "filePath", the buffer of the block if the option is "buffer"
   */
  fetch(channelID: string, seek: 'newest' | 'oldest' | 'config' | number, outputOption: 'filePath' | 'buffer'): string | Buffer {

    const peerConfigs = this.peerConfigs();
    const blockPath = path.join(this.outputDir(), `${channelID}_${seek}.block`);

    const command = ['peer', 'channel', 'fetch', String(seek), blockPath,
      '--channelID', channelID, ...this.peerCmdOrdererArgs()].join(' ');
    execCommand(command, true, undefined, {
      FABRIC_LOGGING_SPEC: this.logLevel(),
      FABRIC_CFG_PATH: this.configPath(),
      CORE_PEER_LOCALMSPID: this.mspID,
      CORE_PEER_MSPCONFIGPATH: this.mspConfigPath,
      CORE_PEER_TLS_ENABLED: 'true',
      CORE_PEER_ADDRESS: peerConfigs[0].address,
      CORE_PEER_TLS_ROOTCERT_FILE: peerConfigs[0].tlsCACertFilePath
    });

    if (outputOption === 'filePath') {
      return blockPath;
    }

    return fs.readFileSync(blockPath);
  }


  /**
   * Sign the ConfigUpdate with the MSP (execute fabric-configtx-cli sign).
   *
   * @param {string} configUpdateBase64 the base64 encoded ConfigUpdate
   * @param {"filePath"|"base64"} outputOption the output option
   * @returns {string} the output file path in which the ConfigSignature is written if the option is "filePath", the base64 encoded ConfigSignature if the option is "base64"
   */
  sign(configUpdateBase64: string, outputOption: 'filePath' | 'base64'): string {

    const opsID = this.generateOpsID();
    const configUpdateSavePath = path.join(this.outputDir(), `fetched_update_${opsID}.pb`);
    const outputFileName = `sign_${opsID}.pb`;

    // Decode ConfigUpdate (delta) from base64 and save to local
    const buffer = Buffer.from(configUpdateBase64, 'base64');
    fs.writeFileSync(configUpdateSavePath, buffer);

    const command = ['fabric-configtx-cli', 'sign',
      '--configTxPath', configUpdateSavePath,
      '--mspID', this.mspID,
      '--certPath', this.getUserCert(),
      '--keyPath', this.getUserKey(),
      '--outputDir', this.outputDir(),
      '--outputFile', outputFileName].join(' ');
    execCommand(command, undefined, undefined, {
      FABRIC_LOGGING_SPEC: this.logLevel()
    });

    // Return the delta file path
    const outputPath = path.join(this.outputDir(), outputFileName);
    if (outputOption === 'filePath') {
      return outputPath;
    }

    // Encode ConfigSignature to base64 and return it
    const signBase64 = fs.readFileSync(outputPath).toString('base64');
    return signBase64;
  }

  /**
   * Create the ConfigUpdate (not enveloped) to create a channel (execute fabric-configtx-cli create-channel).
   *
   * @param {string} channelID the channel ID to be created
   * @param {any} opsProfile the profile to create the channel (the format depends on "fabric-configtx-cli create-channel")
   * @param {"filePath"|"base64"} outputOption the output option
   * @returns {string} the output file path in which the ConfigUpdate is written if the option is "filePath", the base64 encoded ConfigUpdate if the option is "base64"
   */
  createDeltaToCreateChannel(channelID: string, opsProfile: any, outputOption: 'filePath' | 'base64'): string {

    const opsID = this.generateOpsID();
    const profileSavePath = path.join(this.outputDir(), `ops_profile_to_create_${channelID}_${opsID}.json`);
    const outputFileName = `delta_to_create_${channelID}_${opsID}.pb`;

    // Save the profile as yaml to local
    const yamlText = yaml.dump(opsProfile);
    fs.writeFileSync(profileSavePath, yamlText);

    // Create ConfigUpdate (delta) based on the profile
    const command = ['fabric-configtx-cli', 'create-channel',
      '--channelID', channelID,
      '--profile', profileSavePath,
      '--outputDir', this.outputDir(),
      '--outputFile', outputFileName,
      '--outputFormat', 'delta'].join(' ');
    execCommand(command, undefined, undefined, {
      FABRIC_LOGGING_SPEC: this.logLevel()
    });

    // Return the delta file path
    const outputPath = path.join(this.outputDir(), outputFileName);
    if (outputOption === 'filePath') {
      return outputPath;
    }

    // Encode ConfigSignature to base64 and return it
    const signBase64 = fs.readFileSync(outputPath).toString('base64');
    return signBase64;
  }

  /**
   * Create the ConfigUpdate (not enveloped) to update the channel (execute fabric-configtx-cli execute-multiple-ops).
   *
   * @param {string} channelID the channel ID to be created
   * @param {string} configBlockFilePath the path to read the channel config block
   * @param {any} opsProfile the profile to update the channel (the format depends on "fabric-configtx-cli execute-multiple-ops")
   * @param {"filePath"|"base64"} outputOption the output option
   * @returns {string} the output file path in which the ConfigUpdate is written if the option is "filePath", the base64 encoded ConfigUpdate if the option is "base64"
   */
  createDeltaToUpdateChannelByMultipleOperations(channelID: string, configBlockFilePath: string, opsProfile: any, outputOption: 'filePath' | 'base64'): string {

    const opsID = this.generateOpsID();
    const profileSavePath = path.join(this.outputDir(), `ops_profile_to_create_${channelID}_${opsID}.json`);
    const outputFileName = `delta_to_create_${channelID}_${opsID}.pb`;

    // Save the profile as yaml to local
    const yamlText = yaml.dump(opsProfile);
    fs.writeFileSync(profileSavePath, yamlText);

    // Create ConfigUpdate (delta) based on the profile
    const command = ['fabric-configtx-cli', 'execute-multiple-ops',
      '--channelID', channelID,
      '--blockPath', configBlockFilePath,
      '--profile', profileSavePath,
      '--outputDir', this.outputDir(),
      '--outputFile', outputFileName,
      '--outputFormat', 'delta'].join(' ');
    execCommand(command, undefined, undefined, {
      FABRIC_LOGGING_SPEC: this.logLevel()
    });

    // Return the delta file path
    const outputPath = path.join(this.outputDir(), outputFileName);
    if (outputOption === 'filePath') {
      return outputPath;
    }

    // Encode ConfigSignature to base64 and return it
    const signBase64 = fs.readFileSync(outputPath).toString('base64');
    return signBase64;
  }

  /**
   * Create the enveloped configuration transaction with the ConfigUpdate and the ConfigSignatures specified in the profile (execute fabric-configtx-cli create-envelope).
   *
   * @param {string} channelID the channel ID to be created
   * @param {ConfigTxProfile} profile the profile to create the config transaction
   * @returns {string} the output file path in which the enveloped config transaction
   */
  createEnvelope(profile: ConfigTxProfile): string {

    const opsID = this.generateOpsID();
    const profileSavePath = path.join(this.outputDir(), `configtx_profile_${opsID}.json`);
    const outputFileName = `envelope_${opsID}.pb`;

    // Save the configtx profile to local
    fs.writeJSONSync(profileSavePath, profile);

    // Create the envelope based on the profile
    const command = ['fabric-configtx-cli', 'create-envelope',
      '--profile', profileSavePath,
      '--outputDir', this.outputDir(),
      '--outputFile', outputFileName].join(' ');
    execCommand(command, undefined, undefined, {
      FABRIC_LOGGING_SPEC: this.logLevel()
    });


    return path.join(this.outputDir(), outputFileName);
  }

  private getUserKey(): string {
    return findSingleFileOnThePath(path.join(this.mspConfigPath, 'keystore'));
  }

  private getUserCert(): string {
    return findSingleFileOnThePath(path.join(this.mspConfigPath, 'signcerts'));
  }

  private peerConfigs(): PeerConfig[] {
    const regexp = /.+:\/\/(.+)/;
    const peers = this.connectionProfile.peers;
    const peerNames = Object.keys(peers);
    if (peerNames.length < 1) throw new Error('Fail to get peer');

    const peerConfigs: PeerConfig[] = [];
    for (const peerName in peers) {
      const peer = peers[peerName];
      const matches = regexp.exec(peer.url);
      if (matches === null || matches.length < 2) throw new Error(`Fail to parse peer address: ${peer.url}`);
      const address = matches[1];

      let tlsCACertFilePath = peer.tlsCACerts.path;
      if (peer.tlsCACerts.pem) {
        const peerConfigPath = path.join(this.outputDir(), 'peer');
        fs.mkdirpSync(peerConfigPath);
        tlsCACertFilePath = path.join(peerConfigPath, peerName + '_tlsca.crt');
        fs.writeFileSync(tlsCACertFilePath, peer.tlsCACerts.pem);
      }
      peerConfigs.push({ address: address, tlsCACertFilePath: tlsCACertFilePath });
    }
    return peerConfigs;
  }

  private peerCmdOrdererArgs(): string[] {
    const regexp = /.+:\/\/(.+)/;
    const orderers = this.connectionProfile.orderers;
    const ordererNames = Object.keys(orderers);
    if (ordererNames.length < 1) throw new Error('Fail to get orderer');
    const ordererName = ordererNames[0];

    const orderer = orderers[ordererName];
    const matches = regexp.exec(orderer.url);
    if (matches === null || matches.length < 2) throw new Error(`Fail to parse orderer address: ${orderer.url}`);
    const ordererAddress = matches[1];

    // TODO: Should enable name override
    // if (orderer["ssl-target-name-override"]) {
    //   let args: string[] = []
    //   args.push(...["--ordererTLSHostnameOverride", orderer["ssl-target-name-override"]]);
    // }

    let ordererTlsCACertFilePath = orderer.tlsCACerts.path;
    if (orderer.tlsCACerts.pem) {
      const ordererConfigPath = path.join(this.outputDir(), 'orderer');
      fs.mkdirpSync(ordererConfigPath);
      ordererTlsCACertFilePath = path.join(ordererConfigPath, ordererName + '_tlsca.crt');
      fs.writeFileSync(ordererTlsCACertFilePath, orderer.tlsCACerts.pem);
    }
    return ['--tls', '--orderer', ordererAddress, '--cafile', ordererTlsCACertFilePath];
  }

  private generateOpsID(): string {
    return moment().format('MMDD_HHmmss');
  }

  private outputDir(): string {
    if (this._outputDir) {
      return this._outputDir;
    }
    const baseDir = this.options?.workDir ? this.options?.workDir : path.join('/', 'tmp');
    this._outputDir = fs.mkdtempSync(path.join(baseDir, 'channel-commands-'));
    return this._outputDir;
  }

  /**
   * Clean up the output and work folders used by the ChannelCommands.
   */
  public cleanUp() {
    if (this._outputDir) {
      fs.removeSync(this._outputDir);
      this._outputDir = undefined;
    }
  }

  private logLevel(): string {
    return this.options?.fabricLogLevel ? this.options?.fabricLogLevel : 'INFO';
  }

  private configPath(): string {
    return this.options?.fabricConfigPath ? this.options?.fabricConfigPath : path.join('/', 'config');
  }
}